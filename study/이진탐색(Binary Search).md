# 이진탐색(Binary Search)

다음의 배열이 있다.

![이미지](./assets/Binary_Search_1.png)


배열의 데이터 중 9가 있는지 확인하기 위해서 다음과 같은 소스를 짜야 할 것이다.

```c++
// 찾는 값이 있는 index를 리턴한다
int find_index(int arr[], int len, int v) {
    for (int i = 0; i < len; i++)
        if (arr[i] == v)
            return i;
    
    return -1 // 찾는 값이 없을 경우
}
```

이 경우에 찾고자 하는 값이 수열의 뒷쪽에 있거나 값이 없을 때, 모든 배열의 값을 다 탐색한 후에야 index든 -1이든 리턴할 수 있을 것이다. 이를 시간복잡도로 나타내면 O(N)이다.



#### 더 빨리 찾아보자! 어떻게 할 수 있을까?

초등학교를 다닐 때 난 또래 남자아이들 중에서 키가 제일 작았다. 또 생일이 빠른은 아니지만, 생일이 느린 아이들 중에서는 가장 빨라서,  이게 어떤 의미를 갖는가? 내 **출석 번호는 항상 1번**이었다. 초등학교를 다닐 때 출석 번호는 으레 **키 순서 또는 생일 순과 같이 정렬**된 순서였을 것이다. 이를 적용해보자.