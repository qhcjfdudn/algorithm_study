# 구간 트리를 활용해 구간에서 절반 이상이 되는 것 결정하기

1. 정확한 개수를 반환하지 않고, color와 cnt를 계산해가며 가능성이 높은 것을 남긴다.



### 언제 쓰냐?

1 <= c <= 1만개 쯤 되는 c개를 for(int i = 1; i <= C; ++i) 처럼 다 봐야만 비교 가능한 경우에서, 의심되는 하나만 고르기 위해 사용.

구간에서 가장 색이 많을 것 같은 것만 갖고 있으면 좋지 않을까?

아무 색이나 올려도 상관 없는데, 차후 연산에 영향을 주면 안 된다. 그래서 '차'를 이용.

직관적으로 이해하기 위해서.. C가 2개일 때는 아래가 성립.

> 비교했더니, 어떤 색깔이 다른 것들에 비해서 몇 개 더 많더라!

 C가 3 이상일 땐?

차후 연산에 영향을 덜 준다. 라는 게 중요한 부분인 것 같다.



### 고찰

그려보니, 어차피 답이 아닌 것들 중에서는 그나마 많은 거라도 고르는 방법은 아니더라. 

**색이 2개**라면, 서로서로에게 영향을 직접적으로 주기 때문에, **정확한 개수까지 파악 가능**해진다.

3개 이상일 땐? 정확하게 알 수 없다. 데이터가 들어오는 순서에 따라 다양하게 달라지기 때문.

하지만 **답이 될 수 있는 경우만 두고 생각**해볼 때, **절반 이상의 개수를 통한 연산 결과는 어떤 하나의 색깔로 반드시 귀결된다.** ex) 1-9의 구간에서, 1이 5개, 2가 2개, 3이 2개 있다. 이 경우에서 최종 트리 구조에서 나올 수 있는 1의 최솟값은 어떤 경우에서도 (1, 1)(color, cnt) 이상의 모양을 갖는다.(cnt가 더 커질 순 있지만, color가 다른 색깔이거나 cnt가 1보다 작아질 수 없다.) 이로 인해, **실제 답인 경우에서 정상적으로 동작함**을 증명할 수 있다.

1개 구간부터 2개, 3개, ... 몇 가지의 구간에 대한 개수 상황을 나열해보고 이를 통해 분석해보면 그래도 이런 트리를 만들어야 함을 유추해볼 수 있다.